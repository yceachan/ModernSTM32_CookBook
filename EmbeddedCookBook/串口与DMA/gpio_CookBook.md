# IDR与ODR

IDR电平信号与外围引脚同步，而ODR寄存器保存软件最后一次对GPIO所置电平，HAL_READ_PIN库通过读取IDR电平实现

* 对输入数据寄存器的读访问可获取 I/O 状态
*  对输出数据寄存器的读访问可获取最后的写入值

(在非复用模式下)

当ODR置位或复位时，总线立即驱动GPIO外设进行对应的电平操纵，实现为开关NMOS和PMOS，

但引脚电平并不始终与寄存器同步：：

当配置为开漏模式时，MOS的导通状态不一定能决定引脚的实际电平。

此引脚还可以被外围电路“线与”拉低。

> 软件IIC waitack时序:软件对ODR4置1释放SDA，对ODR5置1产生时钟。
>
> 此时IDR5（引脚电平）与ODR5(MOS状态)同步
>
> 而IDR4被从机拉低，ODR4为开漏置1对应的状态，表现为引脚电平为低。

![image-20230418222550919](https://s2.loli.net/2023/04/18/PFSUyIGjVL5pOze.png)

![image-20230418222554158](https://s2.loli.net/2023/04/18/9t7GKrkLSvgFcdB.png)

省流总结：IDR为引脚到总线的只读寄存器，ODR为MOS和总线的可读可写寄存器。

# BSRR与BRR

用于快速写寄存器

传统写ODR方案里，对限定某一位的写需要各种位操作

而BSRR :置1 置位，置0 无效。  想写那个pin,直接将BSRR赋值为那位置1的u16即可。

BRR同理



# 推挽开漏再辨

> 推挽：使用N，Pmos
>
> 开漏：只使用Nmos

![image-20230418225404043](https://s2.loli.net/2023/04/18/CHDs6WuGt1LQPX2.png)

## 为什么推挽不能和其他引脚线与

推挽高，推挽/开漏低时

有一条vdd--nmos---引脚---引脚--pmos-->gnd的回路，形成短路电流

推挽低，开漏高时

有一条vdd---res_up---引脚----引脚--->pmos->gnd的回路，电压都分在res_up上，结果为低，还算合适。。

## 为什么开漏输出线与结果不收上下拉电阻阻值影响？

> newbing :[开漏模式依赖于上拉电阻来提供高电平状态，而低电平状态由晶体管主动创建。因此，上拉网络对VDD具有相对较高的阻抗，而对GND具有非常低的阻抗，因为当晶体管完全导通时，它实际上是一个短路到GND。上拉电阻（例如10k）将更慢地为输出节点充电，因为上拉电阻限制了输出节点从低到高充电的速率，这就是为什么你会在上升沿看到RC类型的响应，而高到低的过渡发生得更快，因为有一个输出晶体管将线路拉低，阻抗相当小](https://electronics.stackexchange.com/questions/620150/difference-between-open-drain-and-push-pull-modes)[1](https://electronics.stackexchange.com/questions/620150/difference-between-open-drain-and-push-pull-modes)。

vdd---res_up---引脚----引脚--->pmos->gnd的回路，电压都分在res_up上，结果为低

因为不会配下拉电阻，是两个上拉开漏的线与x



# 复用

微控制器 I/O 引脚通过一个复用器连接到板载外设/模块，该复用器一次仅允许一个外设的复
用功能 (AF) 连接到 I/O 引脚。这可以确保共用同一个 I/O 引脚的外设之间不会发生冲突。
每个 I/O 引脚都有一个复用器，该复用器采用 16 路复用功能输入（AF0 到 AF15），可通过
GPIOx_AFRL（针对引脚 0 到 7）和 GPIOx_AFRH（针对引脚 8 到 15）寄存器对这些输入
进行配置：
● 完成复位后，所有 I/O 都会连接到系统的复用功能 0 (AF0)。
● 外设的复用功能映射到 AF1 至 AF13。
● Cortex™-M4F EVENTOUT 映射到 AF15。

其复用AF可做GPIO的输出(复用到引脚电平)或输入（复用到IDR寄存器）





# f103 GPIO框图

![image-20230424221854157](https://s2.loli.net/2023/04/24/IOnV9Fom2jW65tB.png)



复用功能 复用功能(AF)
使用默认复用功能前必须对端口位配置寄存器编程。
● 对于复用的输入功能，端口必须配置成输入模式(浮空、上拉或下拉)且输入引脚必须由外部
驱动
注意： 也可以通过**软件模拟复用功能输入**引脚，这种模拟可以通过对 GPIO 控制器编程来实现。此时，端口应当被设置为**复用功能输出模式**。显然，这时相应的引脚不再由外部驱动，而是通过
GPIO 控制器由软件来驱动。
● 对于复用输出功能，端口必须配置成复用功能输出模式(推挽或开漏)。
● 对于双向复用功能，端口位必须配置复用功能输出模式(推挽或开漏)。这时，输入驱动器被
配置成浮空输入模式。
如果把端口配置成复用输出功能，则引脚和输出寄存器断开，并和片上外设的输出信号连接。
如果软件把一个GPIO脚配置成复用输出功能，但是外设没有被激活，它的输出将不确定。



# f407 GPIO框图

![image-20230424221448980](https://s2.loli.net/2023/04/24/pGxLk3yFmN9O5cv.png)



## 输入模式配置

输入配置
对 I/O 端口进行编程作为输入时：
● **输出缓冲器被关闭**
● 施密特触发器输入被打开
● 根据 GPIOx_PUPDR 寄存器中的值决定是否打开上拉和下拉电阻
**● 输入数据寄存器每隔 1 个 AHB1 时钟周期对 I/O 引脚上的数据进行一次采样**
● 对输入数据寄存器的读访问可获取 I/O 状态

![image-20230424223755331](https://s2.loli.net/2023/04/24/JlVMLwuNYi7vT1j.png)

**施密特触发器**是一种**具有迟滞**的**比较器**电路，通过向比较器或差分放大器的同相输入端施加正反馈来实现。施密特触发器使用两个输入不同的阈值电压电平来避免输入信号中的噪声，这种双阈值的作用称为**滞后**。

**“施密特触发器”**名称中的“触发器”来自这样一个事实，即**==输出保持其值，直到输入变化足以“触发”变化。==**

**施密特触发器是一种逻辑输入，将提供滞后或两个阈值电平：高和低。**这将使我们能够减少噪声信号产生的误差，从而产生方波。此外，它还可用于将三角波和正弦波等其他类型的信号转换为方波。

## 输出模式配置

输出配置
对 I/O 端口进行编程作为输出时：
● 输出缓冲器被打开：
— 开漏模式：输出寄存器中的“0”可激活 N-MOS，而输出寄存器中的“1”会使端
口保持高组态 (Hi-Z)（P-MOS 始终不激活）。
— 推挽模式：输出寄存器中的“0”可激活 N-MOS，而输出寄存器中的“1”可激活
P-MOS。
● **施密特触发器输入被打开**
● 根据 GPIOx_PUPDR 寄存器中的值决定是否打开弱上拉电阻和下拉电阻
● 输入数据寄存器每隔 1 个 AHB1 时钟周期对 I/O 引脚上的数据进行一次采样
● 对IDR的读访问可获取 I/O 状态
● 对ODR的读访问可获取最后的写入值



输出模式仍可读取输入，当且仅当开漏上拉输出模式，此电平与外部信号会同步。（且不烧从机PMOS）

## 复用功能配置

对 I/O 端口进行编程作为复用功能时：
● 可将输出缓冲器配置为开漏或推挽
● 输出缓冲器由来自外设的信号驱动（发送器使能和数据）
● 施密特触发器输入被打开
● 根据 GPIOx_PUPDR 寄存器中的值决定是否打开**弱上拉电阻和下拉电阻**
● 输入数据寄存器每隔 1 个 AHB1 时钟周期对 I/O 引脚上的数据进行一次采样
● 对输入数据寄存器的读访问可获取 I/O 状态

## F103对应配置

> 如上框图，仅在输入模式下有上下拉

![image-20230424230608712](https://s2.loli.net/2023/04/24/uCNzpa3fAvwW4Hh.png)